1.
    es6支持按照一定的模式 ,从数组和对象中提取数值,称为结构行为
    先说下数组的结构：
    var [a,b,c] = [1,2,3]
    // a  1  b  2  c  3
    let [, ,c] = [1,2,3]
    // c  3
    这种情况属于结构不完全
    let [a,...b] = [1,2,3]   (es6新出的一种运算符号...)
    // a  1  b  [2,3]
    let [a,b,...c] = [1]
    // a  1  b  undefind  c  []
    这种情况属于结构失败了

    我理解是现在的情况，如果你准备的数据多于变量那你的结构会不完全，但是如果你的变量多于你的准备数据那就回结构失败而出现undefined

    数组的结构支持默认值设置
    let [x=1] = [2] // x 2
    let [x=1] = [] //  x 1 (在es6中使用的严格相等的运算符号=== 去比较两者的对象类型和数值是不是都相同 只有在等于undefined的情况下才会使用默认值)
    let [x=1] = [null] // x null (null不等于undefined)
    let [x=y,y=1] = [1,2] // error 因为在开始结构的时候x需要确定y的值是多少 但是y那个时候还没有赋值 会报错

    对于对象的结构也是很方便的：
    var {foo,bar} = {foo:1,bar:2} // foo 1 bar 2
    其实这是简写模式 如果写全的了 应该是
    {foo:foo,bar:bar} = {foo:1,bar:2}
    因为在对象结构的时候赋值的变量其实是后面的foo bar 在前面的foo bar其实是一个固定的模式，所以我们还可以这样玩
    {foo:aa,bar:bb} = {foo:1,bar:2} // aa 1  bb 2
    也就是说 如果我们之前声明过let aa let bb 这些变量的话 那就会报错原因你知道的 因为不允许声明第二次

    对象的结构也是可以使用默认值的
    var {x=3} = {}  // x 3
    let {x,y=3} = {x:1}  // x 1 y 3
    let {x,y=3} = {x:1,y:2}  // x 1 y 2 (如不是undefined情况下就会不取默认值)

    字符串也支持结构(转换成一个类数组的对象)
    var [a,b,c,d,e] = 'hello'
    // a h b e c l d l e o
    var {length:len} = 'hello'
    // len  5

    数值和布尔值的解构（会先将数值或者布尔值转化成对象再进行解析）
    但是undefined null 都不能转换对象 所以解析不了

    以及在函数传参的时候 也支持数组或者对象的结构

    在对象结构的时候有一点和数组是不同的就是他的无序性质，在对象结构的时候 后面的模式首先会找前面对应相同的模式 去检测如果有的话就直接把值赋值过去，
    如果没有相同的模式，就是undefined 因为没有值赋值给我们声明的变量

    在结构两边嵌套模式不一样的情况时候 也会报错如
    let {foo:{bar}} = {baz:'baz'}
    因为在这个时候foo模式的变量就是一个undefined undefined再找就GG了 兄弟

    实质上这种匹配的效果是只要等号两边的模式相同（也就是数据结构）左边的变量会被赋予对应的值.

    在结构的过程中如果两边的数据类型 是不同的比如一个数组 一个字符串或者一个数字或者一个布尔值 也或者说是一个不可遍历的结构 那么就会报错的。。



