let
    1.定义的区域能出现了块级作用域,所声明的代码只在代码块内是有效的
    {
        let a = 10;
        var b = 11;
    }
    a // 报错
    b // 11

    还有就是在for循环的里面定义的变量i,使用var声明后会泄露到全局里面，如果使用let声明后就会只在代码块内生效,获取不到

    2.不存在变量提升了（记得有一次面试某鱼的时候还被问及了问什么javascript会有变量提升这么个属性,年幼的我当时就蒙蔽了,因为
    在当时我一直认为变量提升是一个不好的地方 以为会让代码写的很不规范...）
    a // 报错

    let a  = 11;
    变量不会再提升上去了,所以看到的代码也会是清晰的结构，先声明再使用

    3.暂时死亡区域（在一个块级代码作用域中，如果存在一个变量的声明，我们使用这个变量或者为其赋值都会导致系统报错）
    #!!! (在函数传参时，定义的变量在es5时基于var，但在es6时基于let)
    a = '123' // 报错
    console.log(a) // error
    let a
    console.log(a) // undefined

    4.不允许重复声明变量

    let a = 10;
    let a = 11; // error
    var a = 12; // error

    上面说到的函数传参也会涉及如
    function fn(arg){
        let arg // error
    }

    但是可以继续在里面嵌套块级作用域

    function fn(arg){
        {
            let arg // ok
        }
    }

const
    1.定义的变量一般都是常量,并且需要在一开始就要给好定值否则会报错(定义后就不可以去改变了这一点与let有区别)
    const aa // error
    const a = 1111; // ok
    a = 12; // error

    2.也会存在块级作用域（同let）

    3.也会存在暂时死亡区（同let）

    4.也会不支持变量提升的情况（同let）

    5.也会不支持声明相同的变量（同let）

    6.const声明的变量不可以改变的是相对于内存上的位置，换句话说你可以在这个内存里自己盖房子，做饭啊 干嘛都行 你懂的
    const arr = [];
    arr = {}; // error
    arr = ['jiegege','jiebaobao'] // ok


总结下：
    1.const let 都不支持声明全局变量，以前的var在全局声明的变量都是window上的,现在不会挂在window上了,但是你要是用var还是会挂..
    2.相对于以前的es5代码，一些for，while循环会泄露变量i的情况 以前实现代码不泄露一般会使用自执行匿名函数，现在可以直接使用let





